"""CLI tool for generating DevVisualizer level files with boilerplate code.

This module provides a command-line interface for creating new DevVisualizer
level files with all necessary boilerplate code, eliminating the need for
users to manually create files.

Usage:
    # With filename argument
    uv run python -m actions.dev.create_level my_level.py

    # Interactive mode (prompts for filename)
    uv run python -m actions.dev.create_level
"""

import os
import re
import subprocess
import sys
from pathlib import Path


def _derive_title_from_filename(filename: str) -> str:
    """Derive a human-readable title from a filename.

    Examples:
        "my_level.py" -> "My Level"
        "boss_fight.py" -> "Boss Fight"
        "level_1.py" -> "Level 1"
    """
    # Remove .py extension
    name = Path(filename).stem

    # Replace underscores and hyphens with spaces
    name = name.replace("_", " ").replace("-", " ")

    # Capitalize each word
    words = name.split()
    title = " ".join(word.capitalize() for word in words)

    return title


def _derive_export_name_from_filename(filename: str) -> str:
    """Derive YAML export name from filename.

    Examples:
        "my_level.py" -> "my_level"
        "boss_fight.py" -> "boss_fight"
    """
    return Path(filename).stem


def _validate_filename(filename: str) -> tuple[bool, str | None]:
    """Validate that filename is acceptable.

    Returns:
        Tuple of (is_valid, error_message)
    """
    if not filename:
        return False, "Filename cannot be empty"

    path = Path(filename)
    if path.name == "":
        return False, "Filename cannot be empty"

    if path.suffix != ".py":
        return False, "Filename must end with .py extension"

    # Check for invalid characters in the final filename only (allow absolute paths on Windows)
    invalid_chars = r'[<>:"|?*\x00-\x1f]'
    if re.search(invalid_chars, path.name):
        return False, f"Filename contains invalid characters: {filename}"

    return True, None


def generate_level_file(filename: str) -> str:
    """Generate a DevVisualizer level file with boilerplate code.

    Args:
        filename: Path to the file to create (must end with .py)

    Returns:
        Absolute path to the created file

    Raises:
        ValueError: If filename is invalid
        OSError: If file cannot be created
    """
    # Validate filename
    is_valid, error_msg = _validate_filename(filename)
    if not is_valid:
        raise ValueError(error_msg or "Invalid filename")

    # Resolve to absolute path
    file_path = Path(filename).resolve()

    # Create parent directories if needed
    file_path.parent.mkdir(parents=True, exist_ok=True)

    # Derive title and export name
    title = _derive_title_from_filename(filename)
    export_name = _derive_export_name_from_filename(filename)

    # Generate boilerplate code
    template = f'''"""
{title} - DevVisualizer Level Editor

Generated by ArcadeActions DevVisualizer level generator.

Usage:
    ARCADEACTIONS_DEVVIZ=1 uv run python {file_path.name}

Workflow:
    1. Run the script - DevVisualizer auto-appears
    2. Press F12 to toggle DevVisualizer main overlay
    3. Press F11 to toggle the sprite palette window
    4. Click sprites in palette to spawn them
    5. Click sprites in main window to select them
    6. Press E to export scene to {export_name}.yaml
    7. Load the YAML in your game
"""

import arcade
from actions import center_window
from actions.dev import enable_dev_visualizer, get_dev_visualizer, register_prototype

WINDOW_WIDTH = 1280
WINDOW_HEIGHT = 720
WINDOW_TITLE = "{title}"

# Register prototypes - these appear in the palette automatically
# No other code needed! DevVisualizer auto-enables when ARCADEACTIONS_DEVVIZ=1


@register_prototype("enemy")
def make_enemy(ctx):
    """Create an enemy sprite."""
    texture = arcade.load_texture(":resources:images/enemies/slimeBlue.png")
    enemy = arcade.Sprite(texture, scale=1.0)
    enemy._prototype_id = "enemy"
    return enemy


class SceneEditorView(arcade.View):
    """Simple view - DevVisualizer handles EVERYTHING automatically!

    DevVisualizer auto-attaches when ARCADEACTIONS_DEVVIZ=1 is set.
    Scene sprites are drawn automatically - zero API calls needed!
    Just register prototypes and create a basic View. That's it!
    """

    def __init__(self):
        super().__init__()
        self.background_color = arcade.color.BLACK

    def on_draw(self):
        """Draw the scene - DevVisualizer draws sprites automatically."""
        self.clear()
        # That's it! DevVisualizer automatically draws scene_sprites
        # No get_dev_visualizer(), no scene_sprites.draw(), nothing!
        # Completely transparent - beginner-friendly!

    def on_key_press(self, key, modifiers):
        """Handle keyboard shortcuts."""
        if key == arcade.key.ESCAPE:
            self.window.close()


def main():
    """Run the scene editor."""
    window = arcade.Window(WINDOW_WIDTH, WINDOW_HEIGHT, WINDOW_TITLE, visible=False)
    center_window(window)
    window.set_visible(True)

    view = SceneEditorView()
    window.show_view(view)

    # Ensure DevVisualizer is attached to this window (auto-enable can run before window exists)
    dev_viz = get_dev_visualizer()
    if dev_viz is None:
        dev_viz = enable_dev_visualizer(window=window, auto_attach=True)
    dev_viz.attach_to_window(window)
    dev_viz.show()

    print("=" * 60)
    print("{title}")
    print("=" * 60)
    print("DevVisualizer auto-enabled! (ARCADEACTIONS_DEVVIZ=1)")
    print("Press F12 to toggle DevVisualizer main overlay")
    print("Press F11 to open/close sprite palette window")
    print("Click prototypes in palette to spawn sprites")
    print("Click sprites in main window to select them")
    print("Press E to export scene to {export_name}.yaml")
    print("Press ESC to exit")
    print("=" * 60)

    arcade.run()


if __name__ == "__main__":
    main()
'''

    # Write file
    file_path.write_text(template, encoding="utf-8")

    return str(file_path)


def run_level_file(filename: str) -> None:
    """Run a level file with DevVisualizer enabled.

    Args:
        filename: Path to the Python file to run

    Raises:
        FileNotFoundError: If file doesn't exist
        subprocess.CalledProcessError: If execution fails
    """
    file_path = Path(filename).resolve()

    if not file_path.exists():
        raise FileNotFoundError(f"File not found: {file_path}")

    # Set environment variable and run
    env = os.environ.copy()
    env["ARCADEACTIONS_DEVVIZ"] = "1"

    try:
        # Use uv run python to execute the file
        subprocess.run(
            ["uv", "run", "python", str(file_path)],
            env=env,
            check=True,
        )
    except subprocess.CalledProcessError as e:
        print(f"Error running {filename}: {e}", file=sys.stderr)
        raise
    except FileNotFoundError:
        print(
            "Error: 'uv' command not found. Make sure uv is installed and in PATH.",
            file=sys.stderr,
        )
        raise


def main() -> None:
    """Main CLI entry point."""
    # Parse command line arguments
    if len(sys.argv) > 1:
        filename = sys.argv[1]
    else:
        # Interactive mode - prompt for filename
        try:
            filename = input("Enter filename for new level (e.g., my_level.py): ").strip()
        except KeyboardInterrupt:
            print("\nCancelled by user.", file=sys.stderr)
            sys.exit(130)
        if not filename:
            print("No filename provided. Exiting.", file=sys.stderr)
            sys.exit(1)

    # Validate filename
    is_valid, error_msg = _validate_filename(filename)
    if not is_valid:
        print(f"Error: {error_msg}", file=sys.stderr)
        sys.exit(1)

    # Check if file exists
    file_path = Path(filename).resolve()
    if file_path.exists():
        try:
            response = input(f"File already exists: {file_path}\nOverwrite? [y/N]: ").strip().lower()
        except KeyboardInterrupt:
            print("\nCancelled by user.", file=sys.stderr)
            sys.exit(130)
        if response not in ("y", "yes"):
            print("Cancelled. Exiting.", file=sys.stderr)
            sys.exit(0)

    try:
        # Generate the file
        created_path = generate_level_file(filename)
        print(f"âœ“ Created level file: {created_path}")

        # Automatically run the file
        print(f"\nRunning {Path(created_path).name} with DevVisualizer enabled...\n")
        run_level_file(created_path)

    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nCancelled by user.", file=sys.stderr)
        sys.exit(130)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
