---
name: 10Ã— Productivity Roadmap for 1942-Style Shooter with ArcadeActions
overview: ""
todos:
  - id: 62f3df2c-8fbb-4aa1-8be6-12e90aadafff
    content: Implement file-watcher and ActionManager.reload for Python modules & map/asset files
    status: pending
  - id: 4f568a96-0572-4a2f-89b6-010453b8dee1
    content: Add incremental Scene/TileMap reload preserving entity state
    status: pending
  - id: 86151052-fdc4-4625-8b51-ee5b2f605518
    content: Build on-screen action inspector and 3-second rewind buffer
    status: pending
  - id: a2207963-a708-4fb8-8501-854a5fa156ec
    content: Develop Tiled JS plug-in to list & validate actions from schema
    status: pending
  - id: 315b7590-840d-4f6d-b598-e10430c7dc6e
    content: Introduce YAML prefab/inheritance loader and Tiled templates
    status: pending
  - id: 683bdf55-39ab-42d8-acd0-89186aeae097
    content: Load JSON/YAML state machines/BTs from map properties
    status: pending
  - id: ebca5585-0eff-423d-9600-8c51b782fe92
    content: Create headless playtest runner and integrate with CI
    status: pending
  - id: d3c3a619-97ed-4d09-a430-092449c180f8
    content: Embed telemetry hooks and local dashboard
    status: pending
  - id: 3c34ca9d-bcab-45db-ba93-3faa86024a35
    content: Parallelize asset optimization with fingerprint cache
    status: pending
  - id: 359dd80d-64fc-4d4f-b9e6-781dc02dbcc1
    content: Publish cookiecutter template bundling all features
    status: pending
---

# 10Ã— Productivity Roadmap for 1942-Style Shooter with ArcadeActions

This plan transforms development of a vertical-scrolling shoot-em-up (1942-style) from manual code placement to a data-driven, hot-reloadable workflow using Tiled, ArcadeActions, and supporting tools.

**Target Game:** Top-down space shooter with large scrolling world maps, formation-based enemy waves, boss encounters, and 8â€“10 authored levels.

**Expected Outcome:** 3-month tooling investment enables 2-month content creation (vs 6 months all-code), approaching 3Ã— on first game, 10Ã— on subsequent projects.

---

## PHASE 1: Core Infrastructure (Must-Have, ~6 weeks)

Ship a playable vertical slice with hot-reload, Tiled integration, and data-driven content.

---

### 1. Hot-Reload Core  (impact â˜…â˜…â˜…â˜…â˜…, week 1â€“2)

**Goal:** See code/data changes in-game within â‰¤1 s, no restart.

**Implementation**

1. Add file-watcher service (`arcade_actions/reload/watch.py`)

- Use `watchdog` library to monitor: `*.py`, `*.tmx`, `*.json`, sprite sheets, audio
- Debounce rapid saves (300ms window)

2. Implement `ActionManager.reload(changed_paths)`

- For Python modules: `importlib.reload(module)`
- For assets: call Scene reload API (Â§2)
- For action registry: re-scan decorators, update function pointers

3. Add game loop hook: freeze updates during swap, preserve player state (position, health, score)
4. Keyboard shortcut: `R` key forces full reload

**Exit Criteria**

- Edit enemy spawn position in Tiled, save â†’ see change in <1 s
- Modify formation behavior Python file â†’ enemies update without losing player progress
- No crashes or state corruption across 20 consecutive reloads

**Files to Create**

- `arcade_actions/reload/watch.py`
- `arcade_actions/reload/manager.py`
- `arcade_actions/core/action_manager.py` (extend existing)

**Dependencies:** None

---

### 2. Scene & Asset Live-Reload  (â˜…â˜…â˜…â˜…â˜†, week 2â€“3)

**Goal:** Incrementally rebuild only changed map layers; handle large scrolling maps efficiently.

**Implementation**

1. Add `Scene.reload_layer(name, new_sprite_list)` in `arcade_actions/scene_patch.py`
2. Factor TileMap loading into helpers:

- `build_tile_layer(tmx_layer) -> SpriteList`
- `build_object_layer(tmx_objects) -> List[Sprite]`
- `apply_spatial_hash(sprite_list, cell_size)`

3. Diff algorithm: hash each layer's JSON; rebuild only modified layers
4. Preserve runtime state: when replacing a sprite, copy custom attributes (health, AI state) if IDs match
5. Optimize for 2000Ã—10000 px maps: only instantiate sprites in visible viewport + 1-screen buffer

**Exit Criteria**

- 2000Ã—10000 map reloads in <200 ms
- Scrolling FPS stays >55 during reload
- Enemy mid-attack preserves animation state after layer reload

**Files to Create**

- `arcade_actions/scene_patch.py`
- `arcade_actions/tilemap/incremental.py`

**Dependencies:** Hot-Reload Core

---

### 3. Tiled Action Plug-in  (â˜…â˜…â˜…â˜…â˜†, week 3â€“4)

**Goal:** Designers select actions from dropdown; no manual JSON typing.

**Implementation**

1. Python schema exporter: `tools/export_action_schema.py`

- Introspects `arcade_actions.registry` using `inspect.signature`
- Outputs `schema/actions.json`:
     ```json
     {
       "spawn_enemy": {
         "args": {
           "enemy_type": {"type": "string", "enum": ["bomber", "fighter", "tank"]},
           "formation": {"type": "string", "default": "line"},
           "count": {"type": "integer", "default": 5}
         },
         "description": "Spawn an enemy formation"
       }
     }
     ```


2. Tiled JavaScript plug-in: `tiled_plugins/arcade_actions.js`

- Reads `actions.json` on startup
- Adds "Action" custom property type with dropdown
- Validates required args on map save; highlights errors in red
- Auto-generates property fields based on arg types

3. GitHub Action: auto-run schema exporter on push to keep JSON in sync

**Exit Criteria**

- Selecting "spawn_enemy" shows 3 input fields (type, formation, count)
- Missing required arg blocks map save with clear error message
- Schema updates within 30s of merging Python changes

**Files to Create**

- `tools/export_action_schema.py`
- `tiled_plugins/arcade_actions.js`
- `.github/workflows/update-schema.yml`

**Dependencies:** Hot-Reload Core (for registry)

---

### 4. Prefab & Inheritance System  (â˜…â˜…â˜…â˜†â˜†, week 4â€“5)

**Goal:** Define reusable entities (enemy types, bosses, power-ups) in YAML; reference from Tiled.

**Implementation**

1. YAML spec in `prefabs/enemies.yaml`:
   ```yaml
   bomber:
     sprite: enemy_bomber.png
     health: 30
     speed: 80
     formation: V-shape
     score: 100
   
   heavy_bomber:
     extends: bomber
     health: 60
     sprite: enemy_bomber_armored.png
     score: 250
   ```

2. Loader: `arcade_actions.prefab.load(name) -> dict`

- Resolves `extends` chain recursively
- Merges parent attrs with overrides

3. Tiled integration: object with `prefab: "bomber"` property auto-fills health, sprite, etc.
4. Hot-reload: watch `prefabs/*.yaml`; refresh all instances on change
5. Optional: generate Tiled External Templates (`.tx` files) for drag-drop placement

**Exit Criteria**

- Changing `bomber.health` in YAML updates all 50 bomber instances across 3 levels on reload
- `heavy_bomber` inherits sprite path correctly
- Tiled shows prefab properties as read-only hints

**Files to Create**

- `arcade_actions/prefab/loader.py`
- `prefabs/enemies.yaml`, `prefabs/bosses.yaml`, `prefabs/powerups.yaml`
- `tools/generate_tiled_templates.py`

**Dependencies:** Hot-Reload Core

---

### 5. Data-Driven Behaviors & Formations  (â˜…â˜…â˜…â˜†â˜†, week 5â€“6)

**Goal:** Author enemy AI and formations as JSON/YAML snippets; no Python edits for common patterns.

**Implementation**

1. Behavior schema in `schema/behaviors.json`:
   ```json
   {
     "patrol_vertical": {
       "type": "movement",
       "pattern": "sine_wave",
       "amplitude": 50,
       "frequency": 2.0
     },
     "dive_bomb": {
       "type": "state_machine",
       "states": {
         "approach": {"duration": 2.0, "next": "dive"},
         "dive": {"speed": 300, "target": "player", "next": "retreat"},
         "retreat": {"speed": 150, "exit_top": true}
       }
     }
   }
   ```

2. Factory: `arcade_actions.behavior.create(behavior_name, sprite) -> StateMachine | BehaviorTree`
3. Formation library: Python classes for V-shape, circle, diamond, staggered-line

- YAML references class name: `formation: V-shape`
- Parameters: `formation_spacing: 40`, `formation_angle: 45`

4. Tiled object properties:
   ```
   behavior: dive_bomb
   formation: V-shape
   formation_count: 5
   ```

5. Boss scripting: multi-phase state machine defined in YAML
   ```yaml
   boss_tank:
     phases:
       - health_threshold: 100
         attacks: [spread_shot, summon_adds]
       - health_threshold: 50
         attacks: [laser_beam, ram_player]
   ```


**Exit Criteria**

- Designer creates new enemy wave (V-formation dive-bombers) entirely in Tiled, no Python
- Boss transitions to phase 2 at 50% health as defined in YAML
- 10 common formations available out-of-box

**Files to Create**

- `arcade_actions/behavior/factory.py`
- `arcade_actions/behavior/formations.py`
- `arcade_actions/behavior/boss_phases.py`
- `schema/behaviors.json`

**Dependencies:** Prefab System

**Special Note:** Complex formations (synchronized sine-wave attacks) may still need Python helpers; YAML references them by name.

---

## ðŸŽ¯ PHASE 1 CHECKPOINT (End of Week 6)

**Deliverable:** Playable demo with 2 levels, 3 enemy types, 1 bossâ€”all authored in Tiled with hot-reload.

**Go/No-Go Decision:**

- If iteration time cut by >50%: proceed to Phase 2
- If <30% improvement: reassess scope or pause

---

## PHASE 2: Developer Experience (High-Value, ~3 weeks)

Debugging and automation tools that slash bug-fix time.

---

### 6. Action Inspector & Time-Travel Debugger  (â˜…â˜…â˜…â˜…â˜†, week 7â€“8)

**Goal:** Visualize triggers, rewind gameplay to reproduce bugs.

**Implementation**

1. Overlay UI in `arcade_actions/inspector/hud.py`

- Draws at screen top-left, semi-transparent background
- Lists last 20 actions: `[âœ“] spawn_enemy(bomber, V-shape, 5)` (green) or `[âœ—] trigger_boss (no target)` (red)

2. Ring buffer: `collections.deque(maxlen=300)` stores `(frame, action, args, result, entity_snapshot)`
3. Keyboard shortcuts:

- `F3`: toggle overlay
- `F7`: rewind 1 second (restore RNG seed, entity positions)
- `F8`: step forward 1 frame

4. Entity snapshots: serialize position, velocity, health, AI state every 10 frames for coarse rewind
5. Fine-grained rewind: replay input buffer for last 60 frames

**Exit Criteria**

- Overlay shows "Boss phase transition failed: health_threshold not met"
- Rewind 3s, see boss had 51 HP (threshold is 50), fix YAML typo
- No performance impact when overlay hidden (<1% CPU)

**Files to Create**

- `arcade_actions/inspector/hud.py`
- `arcade_actions/inspector/recorder.py`
- `arcade_actions/inspector/rewind.py`

**Dependencies:** Hot-Reload Core

---

### 7. Automated Playtest CLI  (â˜…â˜…â˜…â˜†â˜†, week 8â€“9)

**Goal:** Catch regressions (missing bosses, soft-locks) via headless simulation in CI.

**Implementation**

1. CLI: `arcade-actions test levels/level1.tmx --bots 100 --duration 30`
2. Headless mode: use Pyglet's `headless` config, no window creation
3. Bot AI: random movement within bounds, auto-fire, collision avoidance
4. Invariant checks (pluggable):

- `assert_boss_spawned`: fails if boss trigger never fires
- `assert_no_soft_lock`: fails if player stuck >5s
- `assert_all_powerups_reachable`: pathfinding check

5. GitHub Actions workflow: run on every PR
   ```yaml
   - run: arcade-actions test levels/*.tmx --bots 50 --duration 20
   ```

6. Output: JUnit XML for CI integration, screenshots of failure states

**Exit Criteria**

- Broken boss trigger fails CI with clear error: "Boss 'tank' never spawned in level2.tmx"
- 10 levels tested in <2 minutes
- Zero false positives over 20 runs

**Files to Create**

- `arcade_actions_cli/playtest/runner.py`
- `arcade_actions_cli/playtest/bots.py`
- `arcade_actions_cli/playtest/invariants.py`
- `.github/workflows/playtest.yml`

**Dependencies:** Scene Reload (for fast startup)

---

## PHASE 3: Polish & Distribution (Nice-to-Have, ~3 weeks)

Analytics, optimization, and project template for future games.

---

### 8. Analytics & Balance Dashboard  (â˜…â˜…â˜…â˜†â˜†, week 10)

**Goal:** Instrument game, visualize player behavior for tuning.

**Implementation**

1. Telemetry hook: `arcade_actions.telemetry.log(event, **kwargs)`

- Events: `player_death`, `enemy_killed`, `boss_phase_change`, `powerup_collected`
- Buffers locally, flushes to WebSocket every 5s

2. Local server: `tools/telemetry_server.py` (Flask + Plotly Dash)

- Real-time charts: death heat-map, enemy kill counts, average survival time
- Overlay heat-map on Tiled map image

3. Designer workflow:

- See 80% of deaths at (x=500, y=2000)
- Open Tiled, move enemy spawn point
- Reload game, see heat-map shift in real-time

**Exit Criteria**

- Dashboard updates within 2s of in-game event
- Heat-map accurately shows death clusters
- Export CSV for deeper analysis in Excel/Python

**Files to Create**

- `arcade_actions/telemetry/logger.py`
- `tools/telemetry_server.py`
- `tools/templates/dashboard.html`

**Dependencies:** Scene Reload

---

### 9. Parallel Asset Pipeline  (â˜…â˜…â˜†â˜†â˜†, week 11)

**Goal:** Eliminate export/optimize waits; build 500 assets in <20s.

**Implementation**

1. CLI: `arcade-actions build-assets --manifest assets.json`
2. Manifest specifies:
   ```json
   {
     "spritesheets": [
       {"input": "raw/enemies.png", "output": "assets/enemies.png", "quantize": 256}
     ],
     "audio": [
       {"input": "raw/explosion.wav", "output": "assets/explosion.ogg", "bitrate": 128}
     ]
   }
   ```

3. ThreadPoolExecutor: process 8 assets in parallel
4. Fingerprint cache: `sha256` of input file â†’ skip if unchanged
5. Integrations:

- PNG: `pillow-simd` for quantization
- Audio: `ffmpeg` for Ogg conversion

6. Watch mode: `--watch` auto-rebuilds on file change

**Exit Criteria**

- 500 images + 50 audio files build in <20s (vs 2+ min manual)
- Incremental builds: only 3 changed files rebuild in <2s
- Zero quality loss on quantized sprites

**Files to Create**

- `arcade_actions_cli/build/pipeline.py`
- `arcade_actions_cli/build/optimizers.py`

**Dependencies:** None

---

### 10. Opinionated Starter Template  (â˜…â˜…â˜†â˜†â˜†, week 11â€“12)

**Goal:** One-command bootstrap for new 1942-style games.

**Implementation**

1. Cookiecutter repo: `cookiecutter-arcade-shooter`
2. Includes:

- Example level (ocean tileset, 3 enemy waves, 1 boss)
- Prefab pack (5 enemy types, 3 bosses, 4 power-ups)
- GitHub Actions CI (playtest + schema export)
- VSCode launch config with hot-reload debugger
- Pre-configured `pyproject.toml` with all dependencies

3. Interactive prompts:
   ```
   project_name: my_shooter
   screen_width: 800
   screen_height: 600
   player_sprite: ship.png
   ```

4. Documentation: `docs/TUTORIAL.md` walks through creating first level

**Exit Criteria**

- Run `cookiecutter gh:yourname/cookiecutter-arcade-shooter`
- Answer 4 prompts
- `cd my_shooter && uv run game.py` â†’ playable demo in <5 min
- Hot-reload works out-of-box

**Files to Create**

- `cookiecutter-arcade-shooter/` (separate repo)
- `{{cookiecutter.project_name}}/` template structure
- `docs/TUTORIAL.md`

**Dependencies:** Asset Pipeline, Playtest CLI, Analytics

---

## Delivery Strategy

### Sprint Cadence

- **Weeks 1â€“6:** Phase 1 (core infrastructure)
        - Weekly demos showing hot-reload improvements
        - Checkpoint at week 6: measure iteration time savings
- **Weeks 7â€“9:** Phase 2 (DX tools)
        - Inspector ships week 8; playtest CLI week 9
- **Weeks 10â€“12:** Phase 3 (polish)
        - Analytics week 10; pipeline + template weeks 11â€“12

### Risk Mitigation

- **Scrolling performance:** Prototype spatial hashing in week 2; pivot if <60 FPS
- **Formation complexity:** Budget extra 3 days (week 6.5) for custom formation helpers
- **Timeline slips:** Defer analytics (milestone 8) to post-launch if needed

### Version Tagging

- `v0.1.0`: Hot-reload core (end week 2)
- `v0.2.0`: Tiled integration (end week 4)
- `v0.3.0`: Phase 1 complete (end week 6)
- `v1.0.0`: Phase 2 complete (end week 9)
- `v1.1.0`: Phase 3 complete (end week 12)

---

## ROI Calculation

**Without tooling (baseline):**

- 8 levels Ã— 3 weeks each = 24 weeks (6 months)

**With Phase 1 tooling:**

- 3-month build + 8 levels Ã— 1 week each = 5 months (17% faster)

**With Phase 1+2 tooling:**

- 3-month build + 8 levels Ã— 0.5 weeks each = 4 months (33% faster)

**Subsequent games (tooling reused):**

- 8 levels Ã— 0.5 weeks = 1 month (6Ã— faster than baseline)

**Break-even:** After 2 games using this framework.

---

## Success Metrics

Track weekly:

1. **Iteration time:** Seconds from save to in-game change
2. **Bug fix time:** Minutes from report to verified fix
3. **Content velocity:** Levels completed per week
4. **Crash rate:** Reloads before crash (target: >100)

Target by end of Phase 1:

- Iteration time <2s (from 30s baseline)
- 1 level per week (from 3 weeks baseline)

---

When each phase completes, tag the release and update this document with actual vs estimated timelines for future reference.